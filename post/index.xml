<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on MrG</title>
    <link>https://gxk123.github.io/post/</link>
    <description>Recent content in Posts on MrG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Feb 2020 21:59:26 +0800</lastBuildDate>
    
	<atom:link href="https://gxk123.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Test</title>
      <link>https://gxk123.github.io/post/test/</link>
      <pubDate>Sat, 22 Feb 2020 21:59:26 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/test/</guid>
      <description>这是一个测试添加</description>
    </item>
    
    <item>
      <title>Springboot简单介绍</title>
      <link>https://gxk123.github.io/post/newblog/</link>
      <pubDate>Sat, 22 Feb 2020 21:36:09 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/newblog/</guid>
      <description>Springboot入门介绍
一、Spring框架概述
1.1 什么是Spring
Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作《Expert One-On-One J2EE Development and Design》。Spring是为了解决企业级应用开发的复杂性而创建的，使用Spring可以让简单的JavaBean实现之前只有EJB才能完成的事情。但是Spring不仅仅局限于服务器端开发，任何Java应用都能在简单性、可测试性和松耦合性等方面从Spring中获益。
1.2 Spring是如何简化Java开发的
为了降低Java开发的复杂性，Spring采用了以下4种关键策略：
1、基于POJO的轻量级和最小侵入性编程；
2、通过依赖注入（DI）和面向接口实现松耦合；
3、基于切面（AOP）和惯例进行声明式编程；
4、通过切面和模版减少样式代码；
 二、SpringBoot简介
2.1什么是SpringBoot
Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。
2.2、SpringBoot四个主要特性
1、SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；
2、自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；
3、命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；
4、Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。但首先，我们快速了解每项特性，更好的体验他们如何简化Spring编程模型。
2.3 SpringBoot开发的具体好处
回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：
1、配置web.xml，加载spring和spring mvc
2、配置数据库连接、配置spring事务
3、配置加载配置文件的读取，开启注解
。。。
配置完成之后部署tomcat 调试
而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了&amp;hellip;</description>
    </item>
    
    <item>
      <title>Springboot简单介绍</title>
      <link>https://gxk123.github.io/post/springboot/</link>
      <pubDate>Sat, 22 Feb 2020 20:22:24 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/springboot/</guid>
      <description>Springboot入门介绍
一、Spring框架概述
1.1 什么是Spring
Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作《Expert One-On-One J2EE Development and Design》。Spring是为了解决企业级应用开发的复杂性而创建的，使用Spring可以让简单的JavaBean实现之前只有EJB才能完成的事情。但是Spring不仅仅局限于服务器端开发，任何Java应用都能在简单性、可测试性和松耦合性等方面从Spring中获益。
1.2 Spring是如何简化Java开发的
为了降低Java开发的复杂性，Spring采用了以下4种关键策略：
1、基于POJO的轻量级和最小侵入性编程；
2、通过依赖注入（DI）和面向接口实现松耦合；
3、基于切面（AOP）和惯例进行声明式编程；
4、通过切面和模版减少样式代码；
 二、SpringBoot简介
2.1什么是SpringBoot
Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。
2.2、SpringBoot四个主要特性
1、SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；
2、自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；
3、命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；
4、Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。但首先，我们快速了解每项特性，更好的体验他们如何简化Spring编程模型。
2.3 SpringBoot开发的具体好处
回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：
1、配置web.xml，加载spring和spring mvc
2、配置数据库连接、配置spring事务
3、配置加载配置文件的读取，开启注解
。。。
配置完成之后部署tomcat 调试
而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了&amp;hellip;</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://gxk123.github.io/post/xiancheng/</link>
      <pubDate>Sat, 22 Feb 2020 19:53:01 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/xiancheng/</guid>
      <description>多线程 线程与进程的区别 线程池 前台线程和后台线程的区别 线程同步 lock 多线程信号量 开启一个异步线程的几种方式？多线程编程时的注意事项？ 线程交替打印奇偶数 await async 线程与进程的区别 线程(Thread)与进程（Process）二者都定义了某种边界，不同的是进程定义的是应用程序与应用程序之间的边界，不同的进程之间不能共享代码和数据空间，而线程定义的是代码执行堆栈和执行上下文的边界。一个进程可以包括若干个线程，同时创建多个线程来完成某项任务，便是多线程。而同一进程中的不同线程共享代码和数据空间。用一个比喻来说，如果一个家庭代表一个进程，在家庭内部，各个成员就是线程，家庭中的每个成员都有义务对家庭的财富进行积累，同时也有权利对家庭财富进行消费，当面对一个任务的时候，家庭也可以派出几个成员来协同完成，而家庭之外的人则没有办法直接消费不属于自己家庭的财产。
线程池 线程池的使用是非常简单的，如下面的代码，把需要执行的代码提交到线程池，线程池内部会安排一个空闲的线程来执行你的代码，完全不用管理内部是如何进行线程调度的。 优点：减小线程创建和销毁的开销，可以复用线程；也从而减少了线程上下文切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。缺点：线程池无法对一个线程有更多的精确的控制，如了解其运行状态等；不能设置线程的优先级；加入到线程池的任务（方法）不能有返回值；对于需要长期运行的任务就不适合线程池。
前台线程和后台线程的区别 应用程序必须运行完所有的前台线程才可以退出，或者主动结束前台线程，不管后台线程是否还在运行，应用程序都会结束；对于后台线程，应用程序则不考虑是否已经运行完毕而直接退出，所以的后台线程在应用程序退出时自动结束。 通过将Thread.isBackground设置为True，就可以将线程指定为后台线程，主线程就是一个前台线程
线程同步 在多线程中实现线程同步的是线程同步构造，分为两大类，一个是基元构造，一个是混合构造。基元构造分为用户模式和内核模式，而混合构造（如lock）就是综合两种构造模式的优点。
用户模式构造 1.线程1请求了临界资源，并在资源门口使用了用户模式构造的锁； 2 线程2请求临界资源时，发现有锁，因此就在门口等待，并不停的去询问资源是否可用； 3 线程1如果使用资源时间较长，则线程2会一直运行，并且占用CPU时间。占用CPU干什么呢？她会不停的轮询锁的状态，直到资源可用，这就是所谓的活锁 缺点有没有发现？线程2会一直使用CPU时间（假如当前系统只有这两个线程在运行），也就意味着不仅浪费了CPU时间，而且还会有频繁的线程上下文切换，对性能影响是很严重的。 优点是效率高，适合哪种对资源占用时间很短的线程同步 NET中为我们提供了两种原子性操作，利用原子操作可以实现一些简单的用户模式锁（如自旋锁）。 System.Threading.Interlocked：易失构造，它在包含一个简单数据类型的变量上执行原子性的读或写操作。 Thread.VolatileRead 和 Thread.VolatileWrite：互锁构造，它在包含一个简单数据类型的变量上执行原子性的读和写操作。 内核模式构造 线程1请求了临界资源，并在资源门口使用了内核模式构造的锁； 线程2请求临界资源时，发现有锁，就会被系统要求睡眠（阻塞），线程2就不会被执行了，也就不会浪费CPU和线程上下文切换了； 等待线程1使用完资源后，解锁后会发送一个通知，然后操作系统会把线程2唤醒。假如有多个线程在临界资源门口等待，则会挑选一个唤醒； 看上去是不是非常棒！彻底解决了用户模式构造的缺点，但内核模式也有缺点的：将线程从用户模式切换到内核模式（或相反）导致巨大性能损失。调用线程将从托管代码转换为内核代码，再转回来，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此尽量不要让线程从用户模式转到内核模式。 优点就是阻塞线程，不浪费CPU时间，适合那种需要长时间占用资源的线程同步。 内核模式构造的主要有两种方式，以及基于这两种方式的常见的锁： 基于事件：如AutoResetEvent、ManualResetEvent 基于信号量：如Semaphore 混合模式构造 既然内核模式和用户模式都有优缺点，混合构造就是把两者结合，充分利用两者的优点，把性能损失降到最低。大概的思路很好理解，就是如果是在没有资源竞争，或线程使用资源的时间很短，就是用用户模式构造同步，否则就升级到内核模式构造同步，其中最典型的代表就是Lock了。 常用的混合锁还不少呢！如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，这些锁各有特点和锁使用的场景 Mutex（互斥锁）是一个基于内核模式的互斥锁，支持锁的递归调用，而Lock是一个混合锁，一般建议使用Lock更好，因为lock的性能更好。
lock 常用的如如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock是一个混合锁，其实质是Monitor lock的锁对象要求为一个引用类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向一个真正的锁（同步块），这个锁（同步块）会被复用。 Lock语句可以说就是通过Monitor.Enter()和Monitor.Exit()实现的。
当Lock（lockInstance）{}结构开始执行时调用Monitor.Enter（lockInstance）锁定lockInstance临界区，当该结构执行结束，调用monitor.Exit(lockInstance)释放lockInstance临界区。
原理：对于任何一个对象来说,它在内存中的第一部分放置的是所有方法的地址,第二部分放着一个索引,这个索引指向CLR中的SyncBlock Cache区域中的一个SyncBlock。当你执行Monitor.Enter（Object）时，如果object的索引值为负数，就从SyncBlock Cache中选取一个SyncBlock，将其地址放在object的索引中。这样就完成了以object为标志的锁定，其他的线程想再次进行Monitor.Enter(object)操作，将获得object的已经为正值的索引，然后就等待。直到索引变为负数，即调用Monitor.Exit（object)将索引变为负数，等待的线程开始执行。 1.lock不能锁定空值，但Null是不需要被释放的。 2.lock不能锁定string类型，虽然它也是引用类型的。因为字符串类型被CLR“暂留”。即整个程序中任何给定字符串都只有一个实例，具有相同内容的字符串都代表着同一个实例。因此，只要在应用程序进程中的任何位置处具有相同内容的字符串上放置了锁，就将锁定应用程序中与该字符串具有相同内容的字符串。因此，最好锁定不会被暂留的私有或受保护成员。 3.lock锁定的对象是一个程序块的内存边界 4.值类型不能被lock，因为前文标红字的“对象被释放”，值类型不是引用类型的（他要的就是引用类型，如果你传一个值类型，会装箱，下次代码运行到这里，又会装箱，两次不是同一个对象，所以锁不住）
5.lock就避免锁定public 类型或不受程序控制的对象。 例如，如果该实例可以被公开访问，则 lock(this) 可能会有问题，因为不受控制的代码也可能会锁定该对象。这可能导致死锁，即两个或更多个线程等待释放同一对象。出于同样的原因，锁定公共数据类型（相比于对象）也可能导致问题。 使用lock(this)的时候，类的成员变量的值可能会被不在临界区的方法改值了
多线程信号量 信号量控制的只是线程同步的量，而不管顺序，这个例子来说线程控制的就是线程同步量为5，也就是同时并发的线程数量为5个，至于是哪个先哪个后不是由这里的信号量决定的 Semaphore,是负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。也是操作系统中用于控制进程同步互斥的量。
Semaphore常用的方法有两个WaitOne()和Release()， Release()的作用是退出信号量并返回前一个计数， 而WaitOne()则是阻止当前线程，直到当前线程的WaitHandle 收到信号。 这里我举一个例子让大家更容易理解： 当我们这样实例化Semaphore时候。 Semaphore sema = new Semaphore(x,y) 有一队人排队上洗手间，人就相当于线程，x为还剩余的位置数量，y为总的位置数量。 WaitOne()方法就相当于人在等待洗手间位置的行为， 而Release()方法就相当于一个人从洗手间出来的行为， 这里再假设x和y都为5，说明开始的时候洗手间有5个空位置，且总共只有5个位置，当一队超过5个人的队伍要上洗手间的就排队，首先WaitOne()方法等待，发现有空位就依次进去，每进去一个空位减一，直到进去5之后个没有空位，这时候后面的人就一直等待，直到进去的人从洗手间出来Release()方法，空位加一，在等待WaitOne()方法的人发现有空位又进去一个空位减一……如此循环往复。 开启一个异步线程的几种方式？多线程编程时的注意事项？ APM（Asynchrocous Programming Model，比如：BeginXXX、IAsyncResult）、EAP（Event-Based Asynchronous Pattern，比如：DownloadContentAsync）、TPL（Task Parallel Library，比如：Task.</description>
    </item>
    
    <item>
      <title>面试题</title>
      <link>https://gxk123.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sat, 22 Feb 2020 18:27:18 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Java基础面试题 1.面向对象的三个特征
封装：将类的某些信息隐藏在类的内部，不允许外部程序直接访问。只能通过该类提供的 特定的方法 来实现对隐藏信息的操作和访问 继承：提高了代码的复用性，让类与类之间产生了关系 多态：父类引用或者接口的引用指向了自己的子类对象提高了程序的扩展性 2.接口的意义 接口是一种规范，可以快速的分离工作内容 3.抽象类的意义 把一些具有相同属性和方法的组件进行抽象更利于代码的维护和重用，当有新的类时只需要继承这个抽象类就可以获取相应的属性和方法 4.父类的静态方法能否被子类重写? 重写只能适用于实例方法.不能用于静态方法 5.java 创建对象的几种方式 5种 。new 关键字 ； class类的newinstance方法 ； Constructor类的newinstance方法；clone方法；使用反序列化；克隆 6.java中==和eqauls()的区别? == 对比的是两个对象的内存地址是否一样。Eqauls()比较两个对象的内容是否相等 7.&amp;amp; 和 &amp;amp;&amp;amp;的区别 &amp;amp;&amp;amp;具有短路功能，就是前者判断只要是falsae后面就不进行判断了 8.final,finalize()和finally{}的不同之处 final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。
9.int和Integer的区别? Integer是int的包装类，int则是java的一种基本数据类型 Integer变量必须实例化后才能使用，而int变量不需要 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。 Integer的默认值是null，int的默认值是0
10.String,StringBuffer和StringBuilder区别? String底层使用的是final类只能存放不可以改变的字符，StringBuffer线程安全速度慢，StringBuilder线程不安全，速度快 11.String和StringBuffer的区别? 12. StringBuffer和StringBuilder 转发和重定向的区别 1、请求次数：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次； 2、地址栏不同：重定向地址栏会发生变化，转发地址栏不会发生变化； 3、是否共享数据：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）； 4、跳转限制：重定向可以跳转到任意URL，转发只能跳转本站点资源； 5、发生行为不同：重定向是客户端行为，转发是服务器端行为； 2、进程,线程相关 1.说说进程,线程之间的区别? 进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。 2.创建两种线程的方式?他们有什么区别? 继承thread类，实现runnable接口,区别，继承thread类之后不可以继承其它接口，实现简单 3.产生死锁的条件 （1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。&amp;rdquo; 4. Thread 类中的start() 和 run() 方法有什么区别？ run()方法:在本线程内调用该Runnable对象的run()方法，可以重复多次调用； start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程； 4.什么是线程安全？Vector是一个线程安全类吗？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。 如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 是 5.</description>
    </item>
    
  </channel>
</rss>