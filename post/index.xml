<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on MrG</title>
    <link>https://gxk123.github.io/post/</link>
    <description>Recent content in Posts on MrG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Feb 2020 16:01:20 +0800</lastBuildDate>
    
	<atom:link href="https://gxk123.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于程序员的一些笑话</title>
      <link>https://gxk123.github.io/post/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AC%91%E8%AF%9D/</link>
      <pubDate>Sun, 23 Feb 2020 16:01:20 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AC%91%E8%AF%9D/</guid>
      <description>1、“咚咚咚”“谁？”过了很久……“Java” 2、换一个电灯泡需要几个程序员？一个也不要，这是硬件问题。 3、换一个电灯泡需要几个微软程序员？一个也不要，他们会把黑暗变成标准然后告诉每个人：“我们就是这么设计的。” 4、换一个电灯泡需要几个C++程序员？你还在用面向过程的思维考虑问题。一个设计良好的电灯泡类必然封装了换灯泡的方法，所以你要做的就是调用“换电灯泡”方法。 5、一个微软工程师正走在路上，突然听到一只青蛙说：“如果你吻我一下的话，我就会变成漂亮的女人，我们可以结婚，从此幸福地生活在一起。”工程师看着青蛙想了一下，抓起它轻轻地放在自己的上衣口袋里。青蛙把头伸出来说：“怎么，你不准备吻我吗？”“是的”，工程师说：“我在微软工作，没有时间娶妻——不过有一只会说话的青蛙还是挺酷的。” 6、Keyboard not found &amp;hellip; press F1 to continue 7、Unix是用户友好的，只是要成为Unix的用户很困难。 8、一百万只猴子，给他们一百万个键盘，其中的一个会写出Java程序，其它的写的都是Perl程序。 9、程序员给孩子取名：老大叫“灵灵”；老二叫“灵伊”；老三叫“伊灵”；老四叫“伊伊”；老五只能叫“忆初”了… 10、一个新手在试着修复一台坏了的LISP机器，他的方法就是反复关上电源然后打开。专家看到之后，严厉地批评说：“你这样是没用的，你必须要明白出错的深层次原因。” 专家关掉电源，然后打开。运行正常了。 11、老婆给当程序员的老公打电话：“下班顺路买一斤包子带回来，如果看到卖西瓜的，买一个。” 当晚，程序员老公手捧一个包子进了家门。。。 老婆怒道：“你怎么就买了一个包子？！” 老公答曰：“因为看到了卖西瓜的。” 12、两个程序员在聊天：“我昨天碰到个辣妹。我把她带回家，马上就开始如饥似渴地亲吻，她就坐在我的键盘上，然后……”“你在家里也有台电脑？CPU是什么型号的？”13、北京程序员xx遭遇车祸成植物人，医生说活下来希望只有万分之一，唤醒更为渺茫。他的Leader和亲人没放弃，他们根据xx视工作如命的作风，每天都在他身边念：“xx！IE6侧边栏又乱了，线上BUG啊！快起来改！”奇迹发生，xx醒来，第一句话：“我这是好的。” 14、一个程序员骑着一个很漂亮的自行车到了公司，另一个程序员看到了他，问到，“你是从哪搞到的这么漂亮的车的？” 骑车的那个程序员说，“我刚从那边过来，有一个漂亮的姑娘骑着这个车过来，并停在我跟前，把衣服全脱了，然后对我说，‘你想要什么都可以’”。另一个程序员马上说到，“你绝对做了一个正确的选择，因为那姑娘的衣服你并不一定穿得了”。 15、为什么程序员喜爱UNIX:unzip, strip, touch, finger, grep, mount, fsck, more, yes, fsck, fsck, fsck, umount, sleep 16、程序员最讨厌康熙的哪个儿子？ 答：胤禩，因为他是八阿哥。 17、程序员A：“哥们儿，最近手头紧，借点钱？” 程序员B：“成啊，要多少？” 程序员A：“一千行不？” 程序员B：“咱俩谁跟谁！给你凑个整，这一千零二十四，拿去吧。” 18、A：你好，我是程序员。B：哦，程先生！A：客气了，叫我序员就好。 19、有两个程序员钓鱼，其中一个钓到一条美人鱼，这个美人鱼上半身是美女，下半身是鱼，于是这个程序员 就吧她放了，另一个问他：Why，他回答说：没有API。 20、有一个小伙子在一个办公大楼的门口抽着烟，一个妇女路过他身边，并对他说，“你知道不知道这个东西会危害你的健康？我是说，你有没有注意到香烟盒上的那个警告（Warning）？” 小伙子说，“没事儿，我是一个程序员”。 那妇女说，“这又怎样？” 程序员说，“我们从来不关心Warning，只关心Error” 21、一个年轻的程序员和一个产品经理登上了一列在山里行驶的火车，他们发现列车上几乎都坐满了，只有两个在一起的空位，这个空位的对面是一个老奶奶和一个年轻漂亮的姑娘。两个上前坐了下来。程序员和那个姑娘他们比较暧昧地相互看对方。这时，火车进入山洞，车厢里一片漆黑。此时，只听见一个亲嘴的声音，随后就听到一个响亮的巴掌声。很快火车出了山洞，他们四个人都不说话。那个老奶奶在喃喃道，“这个年轻小伙怎么这么无礼，不过我很高兴我的孙女扇了一个巴掌”。产品经理在想，“没想到这个程序员居然这么大胆，敢去亲那姑娘，只可惜那姑娘打错了人，居然给打了我。” 漂亮的姑娘想，“他亲了我真好，希望我的祖母没有打疼他”。 程序员坐在那里露出了笑容，“生活真好啊。这一辈子能有几次机会可以在亲一个美女的同时打产品一巴掌啊！” 22、程序猿最烦两件事，第一件事是别人要他给自己的代码写文档，第二件呢？是别人的程序没有留下文档。 23、程序员的读书历程：x 语言入门 —&amp;gt; x 语言应用实践 —&amp;gt; x 语言高阶编程 —&amp;gt; x 语言的科学与艺术 —&amp;gt; 编程之美 —&amp;gt; 编程之道 —&amp;gt; 编程之禅—&amp;gt; 颈椎病康复指南。 24、还没上大学的时候，高三暑假，跑到家那边的图书城想买传说中的C++的书，然后看到一本C#，我一看，嘿，这个++还写得挺艺术的，重叠起来了，于是把C#买了回来…… 25、有一天，程序猿们突然发现他们要涨的工资掉到井里啦！大家都很害怕，连忙一个吊着一个，从树上伸到井里去捞工资。正好他们摸到工资的时候，一个老程序员忽然兴奋的大叫：别蠢了，要涨的工资还好好的挂在天上呢！ 26、程序猿要了3个孩子，分别取名叫Ctrl、Alt 和Delete，如果他们不听话，程序猿就只要同时敲他们一下就会好的… 27、宪法顶个球！中国的法律都是.</description>
    </item>
    
    <item>
      <title>添加的操作</title>
      <link>https://gxk123.github.io/post/add/</link>
      <pubDate>Sat, 22 Feb 2020 22:05:25 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/add/</guid>
      <description>&amp;mdash;&amp;ndash;根目录操作 1,创建新的文章md hugo new post/newblog.md 2,生成public文件 hugo &amp;ndash;theme=m10c &amp;ndash;baseUrl=&amp;quot;https://gxk123.github.io/&amp;rdquo; &amp;ndash;buildDrafts 3,git init git add . &amp;mdash;-以下是public下操作 4,git add -A 5,git commit -m &amp;ldquo;我的第二次提交&amp;rdquo; 6,git push -u origin master</description>
    </item>
    
    <item>
      <title>Springboot简单介绍</title>
      <link>https://gxk123.github.io/post/springboot/</link>
      <pubDate>Sat, 22 Feb 2020 20:22:24 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/springboot/</guid>
      <description>Springboot入门介绍
一、Spring框架概述
1.1 什么是Spring
Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作《Expert One-On-One J2EE Development and Design》。Spring是为了解决企业级应用开发的复杂性而创建的，使用Spring可以让简单的JavaBean实现之前只有EJB才能完成的事情。但是Spring不仅仅局限于服务器端开发，任何Java应用都能在简单性、可测试性和松耦合性等方面从Spring中获益。
1.2 Spring是如何简化Java开发的
为了降低Java开发的复杂性，Spring采用了以下4种关键策略：
1、基于POJO的轻量级和最小侵入性编程；
2、通过依赖注入（DI）和面向接口实现松耦合；
3、基于切面（AOP）和惯例进行声明式编程；
4、通过切面和模版减少样式代码；
 二、SpringBoot简介
2.1什么是SpringBoot
Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。
2.2、SpringBoot四个主要特性
1、SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中；
2、自动配置：SpringBoot的自动配置特性利用了Spring4对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们；
3、命令行接口：（Command-line-interface, CLI）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发；
4、Actuatir：它为SpringBoot应用的所有特性构建一个小型的应用程序。但首先，我们快速了解每项特性，更好的体验他们如何简化Spring编程模型。
2.3 SpringBoot开发的具体好处
回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：
1、配置web.xml，加载spring和spring mvc
2、配置数据库连接、配置spring事务
3、配置加载配置文件的读取，开启注解
。。。
配置完成之后部署tomcat 调试
而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了&amp;hellip;</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://gxk123.github.io/post/xiancheng/</link>
      <pubDate>Sat, 22 Feb 2020 19:53:01 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/xiancheng/</guid>
      <description>多线程 线程与进程的区别 线程池 前台线程和后台线程的区别 线程同步 lock 多线程信号量 开启一个异步线程的几种方式？多线程编程时的注意事项？ 线程交替打印奇偶数 await async 线程与进程的区别 线程(Thread)与进程（Process）二者都定义了某种边界，不同的是进程定义的是应用程序与应用程序之间的边界，不同的进程之间不能共享代码和数据空间，而线程定义的是代码执行堆栈和执行上下文的边界。一个进程可以包括若干个线程，同时创建多个线程来完成某项任务，便是多线程。而同一进程中的不同线程共享代码和数据空间。用一个比喻来说，如果一个家庭代表一个进程，在家庭内部，各个成员就是线程，家庭中的每个成员都有义务对家庭的财富进行积累，同时也有权利对家庭财富进行消费，当面对一个任务的时候，家庭也可以派出几个成员来协同完成，而家庭之外的人则没有办法直接消费不属于自己家庭的财产。
线程池 线程池的使用是非常简单的，如下面的代码，把需要执行的代码提交到线程池，线程池内部会安排一个空闲的线程来执行你的代码，完全不用管理内部是如何进行线程调度的。 优点：减小线程创建和销毁的开销，可以复用线程；也从而减少了线程上下文切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。缺点：线程池无法对一个线程有更多的精确的控制，如了解其运行状态等；不能设置线程的优先级；加入到线程池的任务（方法）不能有返回值；对于需要长期运行的任务就不适合线程池。
前台线程和后台线程的区别 应用程序必须运行完所有的前台线程才可以退出，或者主动结束前台线程，不管后台线程是否还在运行，应用程序都会结束；对于后台线程，应用程序则不考虑是否已经运行完毕而直接退出，所以的后台线程在应用程序退出时自动结束。 通过将Thread.isBackground设置为True，就可以将线程指定为后台线程，主线程就是一个前台线程
线程同步 在多线程中实现线程同步的是线程同步构造，分为两大类，一个是基元构造，一个是混合构造。基元构造分为用户模式和内核模式，而混合构造（如lock）就是综合两种构造模式的优点。
用户模式构造 1.线程1请求了临界资源，并在资源门口使用了用户模式构造的锁； 2 线程2请求临界资源时，发现有锁，因此就在门口等待，并不停的去询问资源是否可用； 3 线程1如果使用资源时间较长，则线程2会一直运行，并且占用CPU时间。占用CPU干什么呢？她会不停的轮询锁的状态，直到资源可用，这就是所谓的活锁 缺点有没有发现？线程2会一直使用CPU时间（假如当前系统只有这两个线程在运行），也就意味着不仅浪费了CPU时间，而且还会有频繁的线程上下文切换，对性能影响是很严重的。 优点是效率高，适合哪种对资源占用时间很短的线程同步 NET中为我们提供了两种原子性操作，利用原子操作可以实现一些简单的用户模式锁（如自旋锁）。 System.Threading.Interlocked：易失构造，它在包含一个简单数据类型的变量上执行原子性的读或写操作。 Thread.VolatileRead 和 Thread.VolatileWrite：互锁构造，它在包含一个简单数据类型的变量上执行原子性的读和写操作。 内核模式构造 线程1请求了临界资源，并在资源门口使用了内核模式构造的锁； 线程2请求临界资源时，发现有锁，就会被系统要求睡眠（阻塞），线程2就不会被执行了，也就不会浪费CPU和线程上下文切换了； 等待线程1使用完资源后，解锁后会发送一个通知，然后操作系统会把线程2唤醒。假如有多个线程在临界资源门口等待，则会挑选一个唤醒； 看上去是不是非常棒！彻底解决了用户模式构造的缺点，但内核模式也有缺点的：将线程从用户模式切换到内核模式（或相反）导致巨大性能损失。调用线程将从托管代码转换为内核代码，再转回来，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此尽量不要让线程从用户模式转到内核模式。 优点就是阻塞线程，不浪费CPU时间，适合那种需要长时间占用资源的线程同步。 内核模式构造的主要有两种方式，以及基于这两种方式的常见的锁： 基于事件：如AutoResetEvent、ManualResetEvent 基于信号量：如Semaphore 混合模式构造 既然内核模式和用户模式都有优缺点，混合构造就是把两者结合，充分利用两者的优点，把性能损失降到最低。大概的思路很好理解，就是如果是在没有资源竞争，或线程使用资源的时间很短，就是用用户模式构造同步，否则就升级到内核模式构造同步，其中最典型的代表就是Lock了。 常用的混合锁还不少呢！如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，这些锁各有特点和锁使用的场景 Mutex（互斥锁）是一个基于内核模式的互斥锁，支持锁的递归调用，而Lock是一个混合锁，一般建议使用Lock更好，因为lock的性能更好。
lock 常用的如如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock是一个混合锁，其实质是Monitor lock的锁对象要求为一个引用类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向一个真正的锁（同步块），这个锁（同步块）会被复用。 Lock语句可以说就是通过Monitor.Enter()和Monitor.Exit()实现的。
当Lock（lockInstance）{}结构开始执行时调用Monitor.Enter（lockInstance）锁定lockInstance临界区，当该结构执行结束，调用monitor.Exit(lockInstance)释放lockInstance临界区。
原理：对于任何一个对象来说,它在内存中的第一部分放置的是所有方法的地址,第二部分放着一个索引,这个索引指向CLR中的SyncBlock Cache区域中的一个SyncBlock。当你执行Monitor.Enter（Object）时，如果object的索引值为负数，就从SyncBlock Cache中选取一个SyncBlock，将其地址放在object的索引中。这样就完成了以object为标志的锁定，其他的线程想再次进行Monitor.Enter(object)操作，将获得object的已经为正值的索引，然后就等待。直到索引变为负数，即调用Monitor.Exit（object)将索引变为负数，等待的线程开始执行。 1.lock不能锁定空值，但Null是不需要被释放的。 2.lock不能锁定string类型，虽然它也是引用类型的。因为字符串类型被CLR“暂留”。即整个程序中任何给定字符串都只有一个实例，具有相同内容的字符串都代表着同一个实例。因此，只要在应用程序进程中的任何位置处具有相同内容的字符串上放置了锁，就将锁定应用程序中与该字符串具有相同内容的字符串。因此，最好锁定不会被暂留的私有或受保护成员。 3.lock锁定的对象是一个程序块的内存边界 4.值类型不能被lock，因为前文标红字的“对象被释放”，值类型不是引用类型的（他要的就是引用类型，如果你传一个值类型，会装箱，下次代码运行到这里，又会装箱，两次不是同一个对象，所以锁不住）
5.lock就避免锁定public 类型或不受程序控制的对象。 例如，如果该实例可以被公开访问，则 lock(this) 可能会有问题，因为不受控制的代码也可能会锁定该对象。这可能导致死锁，即两个或更多个线程等待释放同一对象。出于同样的原因，锁定公共数据类型（相比于对象）也可能导致问题。 使用lock(this)的时候，类的成员变量的值可能会被不在临界区的方法改值了
多线程信号量 信号量控制的只是线程同步的量，而不管顺序，这个例子来说线程控制的就是线程同步量为5，也就是同时并发的线程数量为5个，至于是哪个先哪个后不是由这里的信号量决定的 Semaphore,是负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。也是操作系统中用于控制进程同步互斥的量。
Semaphore常用的方法有两个WaitOne()和Release()， Release()的作用是退出信号量并返回前一个计数， 而WaitOne()则是阻止当前线程，直到当前线程的WaitHandle 收到信号。 这里我举一个例子让大家更容易理解： 当我们这样实例化Semaphore时候。 Semaphore sema = new Semaphore(x,y) 有一队人排队上洗手间，人就相当于线程，x为还剩余的位置数量，y为总的位置数量。 WaitOne()方法就相当于人在等待洗手间位置的行为， 而Release()方法就相当于一个人从洗手间出来的行为， 这里再假设x和y都为5，说明开始的时候洗手间有5个空位置，且总共只有5个位置，当一队超过5个人的队伍要上洗手间的就排队，首先WaitOne()方法等待，发现有空位就依次进去，每进去一个空位减一，直到进去5之后个没有空位，这时候后面的人就一直等待，直到进去的人从洗手间出来Release()方法，空位加一，在等待WaitOne()方法的人发现有空位又进去一个空位减一……如此循环往复。 开启一个异步线程的几种方式？多线程编程时的注意事项？ APM（Asynchrocous Programming Model，比如：BeginXXX、IAsyncResult）、EAP（Event-Based Asynchronous Pattern，比如：DownloadContentAsync）、TPL（Task Parallel Library，比如：Task.</description>
    </item>
    
    <item>
      <title>面试题</title>
      <link>https://gxk123.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Sat, 22 Feb 2020 18:27:18 +0800</pubDate>
      
      <guid>https://gxk123.github.io/post/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>Java基础面试题 1.面向对象的三个特征
封装：将类的某些信息隐藏在类的内部，不允许外部程序直接访问。只能通过该类提供的 特定的方法 来实现对隐藏信息的操作和访问 继承：提高了代码的复用性，让类与类之间产生了关系 多态：父类引用或者接口的引用指向了自己的子类对象提高了程序的扩展性 2.接口的意义 接口是一种规范，可以快速的分离工作内容 3.抽象类的意义 把一些具有相同属性和方法的组件进行抽象更利于代码的维护和重用，当有新的类时只需要继承这个抽象类就可以获取相应的属性和方法 4.父类的静态方法能否被子类重写? 重写只能适用于实例方法.不能用于静态方法 5.java 创建对象的几种方式 5种 。new 关键字 ； class类的newinstance方法 ； Constructor类的newinstance方法；clone方法；使用反序列化；克隆 6.java中==和eqauls()的区别? == 对比的是两个对象的内存地址是否一样。Eqauls()比较两个对象的内容是否相等 7.&amp;amp; 和 &amp;amp;&amp;amp;的区别 &amp;amp;&amp;amp;具有短路功能，就是前者判断只要是falsae后面就不进行判断了 8.final,finalize()和finally{}的不同之处 final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。
9.int和Integer的区别? Integer是int的包装类，int则是java的一种基本数据类型 Integer变量必须实例化后才能使用，而int变量不需要 Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。 Integer的默认值是null，int的默认值是0
10.String,StringBuffer和StringBuilder区别? String底层使用的是final类只能存放不可以改变的字符，StringBuffer线程安全速度慢，StringBuilder线程不安全，速度快 11.String和StringBuffer的区别? 12. StringBuffer和StringBuilder 转发和重定向的区别 1、请求次数：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次； 2、地址栏不同：重定向地址栏会发生变化，转发地址栏不会发生变化； 3、是否共享数据：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）； 4、跳转限制：重定向可以跳转到任意URL，转发只能跳转本站点资源； 5、发生行为不同：重定向是客户端行为，转发是服务器端行为； 2、进程,线程相关 1.说说进程,线程之间的区别? 进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。 2.创建两种线程的方式?他们有什么区别? 继承thread类，实现runnable接口,区别，继承thread类之后不可以继承其它接口，实现简单 3.产生死锁的条件 （1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。&amp;rdquo; 4. Thread 类中的start() 和 run() 方法有什么区别？ run()方法:在本线程内调用该Runnable对象的run()方法，可以重复多次调用； start()方法:启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程； 4.什么是线程安全？Vector是一个线程安全类吗？ 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。 如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 是 5.</description>
    </item>
    
  </channel>
</rss>